# 为什么会有跨域
    - 浏览器存在同源策略 （安全性）不能让任何一个前端都可以访问后端
    - https://192.168.3.0:3000 /home
    - 协议    域名         端口   路径
    - 协议-域名- 端口 都相同才能叫同源  不同的项目不可能在同一个端口 所以必须存在跨域问题
# 解决方案
    - JSONP
        前端借助script 标签的src属性不受同源策略的限制的特性，携带参数callback向后端发送请求，后端收到请求后解析url得到参数，并将这个参数结合需要返回的数据 形成一个函数调用的形式 const result = `${cb}('${data}')`返回到前端，前端收到后会视为函数调用自行执行这个函数，所以在此之前，我们需要在全局挂载上这样一个函数，将返回的数据data reslove出来 这样就可以在前端得到这个数据。
        如果是其他数据类型，则可以使用JSON.stringify(data) 转换成字符串格式 在前端再使用JSON.parse()转为对象

    - cors
        通过在相应头中加入一些额外的字段，比如Access-Control-Allow-Origin: * 来告诉浏览器这个请求是允许的源，或是方法、允许的请求头等等，来通知浏览器此时同源策略不需要生效，这样就可以解决跨域问题

    - websocket
        天生就不受同源策略的限制，可以通过websocket来进行跨域请求

    - postMessage
        父级页面使用postMessage方法向ifeame内嵌在自己内部的子集页面进行相互通讯
    - document.domain
        通过设置document.domain来解决跨域问题

    - nginx
        在服务器上安装一个nginx，他提供了配置文件，只需要修改一些配置项就可以实现启动一个代理服务，
        同node代理服务一样，只需要在nginx的配置文件中配置一下代理服务即可解决跨域问题
        